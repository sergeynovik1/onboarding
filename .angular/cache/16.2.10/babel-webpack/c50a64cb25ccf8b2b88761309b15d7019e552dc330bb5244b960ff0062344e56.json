{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, LOCALE_ID, Inject, EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, Output, NgModule } from '@angular/core';\nimport * as i3 from '@angular/common';\nimport { formatDate, CommonModule } from '@angular/common';\nfunction CountdownComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"span\", 2);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"innerHTML\", ctx_r0.i.text, i0.ɵɵsanitizeHtml);\n  }\n}\nfunction CountdownComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nconst _c0 = function (a0) {\n  return {\n    $implicit: a0\n  };\n};\nvar CountdownStatus;\n(function (CountdownStatus) {\n  CountdownStatus[CountdownStatus[\"ing\"] = 0] = \"ing\";\n  CountdownStatus[CountdownStatus[\"pause\"] = 1] = \"pause\";\n  CountdownStatus[CountdownStatus[\"stop\"] = 2] = \"stop\";\n  CountdownStatus[CountdownStatus[\"done\"] = 3] = \"done\";\n})(CountdownStatus || (CountdownStatus = {}));\nclass CountdownTimer {\n  constructor(ngZone) {\n    this.ngZone = ngZone;\n    this.fns = [];\n    this.commands = [];\n    this.nextTime = 0;\n    this.ing = false;\n  }\n  start() {\n    if (this.ing === true) {\n      return;\n    }\n    this.ing = true;\n    this.nextTime = +new Date();\n    this.ngZone.runOutsideAngular(() => {\n      this.process();\n    });\n  }\n  process() {\n    while (this.commands.length) {\n      this.commands.shift()();\n    }\n    let diff = +new Date() - this.nextTime;\n    const count = 1 + Math.floor(diff / 100);\n    diff = 100 - diff % 100;\n    this.nextTime += 100 * count;\n    for (let i = 0, len = this.fns.length; i < len; i += 2) {\n      let frequency = this.fns[i + 1];\n      // 100/s\n      if (0 === frequency) {\n        this.fns[i](count);\n        // 1000/s\n      } else {\n        // 先把末位至0，再每次加2\n        frequency += 2 * count - 1;\n        const step = Math.floor(frequency / 20);\n        if (step > 0) {\n          this.fns[i](step);\n        }\n        // 把末位还原成1\n        this.fns[i + 1] = frequency % 20 + 1;\n      }\n    }\n    if (!this.ing) {\n      return;\n    }\n    setTimeout(() => this.process(), diff);\n  }\n  add(fn, frequency) {\n    this.commands.push(() => {\n      this.fns.push(fn);\n      this.fns.push(frequency === 1000 ? 1 : 0);\n      this.ing = true;\n    });\n    return this;\n  }\n  remove(fn) {\n    this.commands.push(() => {\n      const i = this.fns.indexOf(fn);\n      if (i !== -1) {\n        this.fns.splice(i, 2);\n      }\n      this.ing = this.fns.length > 0;\n    });\n    return this;\n  }\n  static #_ = this.ɵfac = function CountdownTimer_Factory(t) {\n    return new (t || CountdownTimer)(i0.ɵɵinject(i0.NgZone));\n  };\n  static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CountdownTimer,\n    factory: CountdownTimer.ɵfac\n  });\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CountdownTimer, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i0.NgZone\n    }];\n  }, null);\n})();\n\n// tslint:disable: no-inferrable-types\nclass CountdownGlobalConfig {\n  constructor(locale) {\n    this.locale = locale;\n    this.demand = false;\n    this.leftTime = 0;\n    this.format = 'HH:mm:ss';\n    this.timezone = '+0000';\n    this.formatDate = ({\n      date,\n      formatStr,\n      timezone\n    }) => {\n      return formatDate(new Date(date), formatStr, this.locale, timezone || this.timezone || '+0000');\n    };\n  }\n  static #_ = this.ɵfac = function CountdownGlobalConfig_Factory(t) {\n    return new (t || CountdownGlobalConfig)(i0.ɵɵinject(LOCALE_ID));\n  };\n  static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CountdownGlobalConfig,\n    factory: CountdownGlobalConfig.ɵfac,\n    providedIn: 'root'\n  });\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CountdownGlobalConfig, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [LOCALE_ID]\n      }]\n    }];\n  }, null);\n})();\nclass CountdownComponent {\n  set config(i) {\n    if (i.notify != null && !Array.isArray(i.notify) && i.notify > 0) {\n      i.notify = [i.notify];\n    }\n    this._config = i;\n  }\n  get config() {\n    return this._config;\n  }\n  constructor(locale, timer, defCog, cdr, ngZone) {\n    this.locale = locale;\n    this.timer = timer;\n    this.defCog = defCog;\n    this.cdr = cdr;\n    this.ngZone = ngZone;\n    this.frequency = 1000;\n    this._notify = {};\n    this.status = CountdownStatus.ing;\n    this.isDestroy = false;\n    this.i = {};\n    this.left = 0;\n    this.event = new EventEmitter();\n  }\n  /**\n   * Start countdown, you must manually call when `demand: false`\n   */\n  begin() {\n    this.status = CountdownStatus.ing;\n    this.callEvent('start');\n  }\n  /**\n   * Restart countdown\n   */\n  restart() {\n    if (this.status !== CountdownStatus.stop) {\n      this.destroy();\n    }\n    this.init();\n    this.callEvent('restart');\n  }\n  /**\n   * Stop countdown, must call `restart` when stopped, it's different from pause, unable to recover\n   */\n  stop() {\n    if (this.status === CountdownStatus.stop) {\n      return;\n    }\n    this.status = CountdownStatus.stop;\n    this.destroy();\n    this.callEvent('stop');\n  }\n  /**\n   * Pause countdown, you can use `resume` to recover again\n   */\n  pause() {\n    if (this.status === CountdownStatus.stop || this.status === CountdownStatus.pause) {\n      return;\n    }\n    this.status = CountdownStatus.pause;\n    this.callEvent('pause');\n  }\n  /**\n   * Resume countdown\n   */\n  resume() {\n    if (this.status === CountdownStatus.stop || this.status !== CountdownStatus.pause) {\n      return;\n    }\n    this.status = CountdownStatus.ing;\n    this.callEvent('resume');\n  }\n  callEvent(action) {\n    this.event.emit({\n      action,\n      left: this.left,\n      status: this.status,\n      text: this.i.text\n    });\n  }\n  init() {\n    const {\n      locale,\n      defCog\n    } = this;\n    const config = this.config = {\n      ...new CountdownGlobalConfig(locale),\n      ...defCog,\n      ...this.config\n    };\n    // tslint:disable-next-line: no-bitwise\n    const frq = this.frequency = ~config.format.indexOf('S') ? 100 : 1000;\n    this.status = config.demand ? CountdownStatus.pause : CountdownStatus.ing;\n    this.getLeft();\n    // bind reflow to me\n    const _reflow = this.reflow;\n    this.reflow = (count = 0, force = false) => _reflow.apply(this, [count, force]);\n    if (Array.isArray(config.notify)) {\n      config.notify.forEach(time => {\n        if (time < 1) {\n          throw new Error(`The notify config must be a positive integer.`);\n        }\n        time = time * 1000;\n        time = time - time % frq;\n        this._notify[time] = true;\n      });\n    }\n    this.timer.add(this.reflow, frq).start();\n    this.reflow(0, true);\n  }\n  destroy() {\n    this.timer.remove(this.reflow);\n    return this;\n  }\n  /**\n   * 更新时钟\n   */\n  reflow(count = 0, force = false) {\n    if (this.isDestroy) {\n      return;\n    }\n    const {\n      status,\n      config,\n      _notify\n    } = this;\n    if (!force && status !== CountdownStatus.ing) {\n      return;\n    }\n    let value = this.left = this.left - this.frequency * count;\n    if (value < 1) {\n      value = 0;\n    }\n    this.i = {\n      value,\n      text: config.formatDate({\n        date: value,\n        formatStr: config.format,\n        timezone: config.timezone\n      })\n    };\n    if (typeof config.prettyText === 'function') {\n      this.i.text = config.prettyText(this.i.text);\n    }\n    this.cdr.detectChanges();\n    if (config.notify === 0 || _notify[value]) {\n      this.ngZone.run(() => {\n        this.callEvent('notify');\n      });\n    }\n    if (value === 0) {\n      this.ngZone.run(() => {\n        this.status = CountdownStatus.done;\n        this.destroy();\n        this.callEvent('done');\n      });\n    }\n  }\n  /**\n   * 获取倒计时剩余帧数\n   */\n  getLeft() {\n    const {\n      config,\n      frequency\n    } = this;\n    let left = config.leftTime * 1000;\n    const end = config.stopTime;\n    if (!left && end) {\n      left = end - new Date().getTime();\n    }\n    this.left = left - left % frequency;\n  }\n  ngOnInit() {\n    this.init();\n    if (!this.config.demand) {\n      this.begin();\n    }\n  }\n  ngOnDestroy() {\n    this.isDestroy = true;\n    this.destroy();\n  }\n  ngOnChanges(changes) {\n    if (!changes.config.firstChange) {\n      this.restart();\n    }\n  }\n  static #_ = this.ɵfac = function CountdownComponent_Factory(t) {\n    return new (t || CountdownComponent)(i0.ɵɵdirectiveInject(LOCALE_ID), i0.ɵɵdirectiveInject(CountdownTimer), i0.ɵɵdirectiveInject(CountdownGlobalConfig), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CountdownComponent,\n    selectors: [[\"countdown\"]],\n    hostVars: 2,\n    hostBindings: function CountdownComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"count-down\", true);\n      }\n    },\n    inputs: {\n      config: \"config\",\n      render: \"render\"\n    },\n    outputs: {\n      event: \"event\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([CountdownTimer]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 2,\n    vars: 5,\n    consts: [[4, \"ngIf\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [3, \"innerHTML\"]],\n    template: function CountdownComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, CountdownComponent_ng_container_0_Template, 2, 1, \"ng-container\", 0);\n        i0.ɵɵtemplate(1, CountdownComponent_ng_container_1_Template, 1, 0, \"ng-container\", 1);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", !ctx.render);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.render)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(3, _c0, ctx.i));\n      }\n    },\n    dependencies: [CommonModule, i3.NgIf, i3.NgTemplateOutlet],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CountdownComponent, [{\n    type: Component,\n    args: [{\n      selector: 'countdown',\n      template: `\n    <ng-container *ngIf=\"!render\">\n      <span [innerHTML]=\"i.text\"></span>\n    </ng-container>\n    <ng-container *ngTemplateOutlet=\"render; context: { $implicit: i }\"></ng-container>\n  `,\n      host: {\n        '[class.count-down]': 'true'\n      },\n      encapsulation: ViewEncapsulation.None,\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      imports: [CommonModule],\n      providers: [CountdownTimer],\n      standalone: true\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [LOCALE_ID]\n      }]\n    }, {\n      type: CountdownTimer\n    }, {\n      type: CountdownGlobalConfig\n    }, {\n      type: i0.ChangeDetectorRef\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    config: [{\n      type: Input,\n      args: [{\n        required: true\n      }]\n    }],\n    render: [{\n      type: Input\n    }],\n    event: [{\n      type: Output\n    }]\n  });\n})();\nclass CountdownModule {\n  static #_ = this.ɵfac = function CountdownModule_Factory(t) {\n    return new (t || CountdownModule)();\n  };\n  static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CountdownModule\n  });\n  static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CountdownComponent]\n  });\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CountdownModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CountdownComponent],\n      exports: [CountdownComponent]\n    }]\n  }], null, null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CountdownComponent, CountdownGlobalConfig, CountdownModule, CountdownStatus, CountdownTimer };\n//# sourceMappingURL=ngx-countdown.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}